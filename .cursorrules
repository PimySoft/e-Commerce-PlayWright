# Playwright Automation Coding Standards

## 1. Getters Over Readonly or Const
- **ALWAYS** use getters for locators in Page Object Models
- **NEVER** use `readonly` or `const` for locator properties
- Getters ensure locators are always fresh and evaluated lazily
- Example:
  ```typescript
  // ✅ CORRECT
  get searchInput(): Locator {
    return this.page.getByRole('textbox', { name: /search/i });
  }
  
  // ❌ WRONG
  readonly searchInput = this.page.getByRole('textbox', { name: /search/i });
  const searchInput = page.getByRole('textbox', { name: /search/i });
  ```

## 2. No Useless Comments
- **REMOVE** all JSDoc comments that simply restate what the code does
- **REMOVE** comments that describe obvious functionality
- **KEEP** only comments that explain "why" not "what"
- Example:
  ```typescript
  // ✅ CORRECT - No comment needed
  get searchInput(): Locator {
    return this.page.getByRole('textbox', { name: /search/i });
  }
  
  // ❌ WRONG - Useless comment
  /**
   * Search input field locator using role
   */
  get searchInput(): Locator {
    return this.page.getByRole('textbox', { name: /search/i });
  }
  ```

## 3. Actions and Selectors Must Be Separate
- **ORGANIZE** Page Object classes with clear separation:
  1. All selectors (getters) grouped together at the top
  2. All actions (methods) grouped together at the bottom
- **NEVER** mix selectors and actions randomly
- Use clear visual separation (blank line between sections)
- Example:
  ```typescript
  export class HomePage extends BasePage {
    // ========== SELECTORS ==========
    get searchInput(): Locator { ... }
    get searchButton(): Locator { ... }
    
    // ========== ACTIONS ==========
    async searchForProduct(productName: string): Promise<void> { ... }
    async goToLogin(): Promise<void> { ... }
  }
  ```

## 4. Priority to Locators By Role
- **ALWAYS** prioritize `getByRole()` over other locator strategies
- **USE** `getByRole()` as the primary locator method
- **FALLBACK** to other locators only when role-based locators are not available
- Order of preference:
  1. `getByRole()` - Highest priority
  2. `getByLabel()` - For form labels
  3. `getByPlaceholder()` - For input placeholders
  4. `getByText()` - For text content
  5. `getByTestId()` - For test IDs (if available)
  6. CSS/XPath - Last resort only
- Example:
  ```typescript
  // ✅ CORRECT - Using getByRole
  get searchButton(): Locator {
    return this.page.getByRole('button', { name: /search/i });
  }
  
  // ❌ WRONG - Using CSS selector when role is available
  get searchButton(): Locator {
    return this.page.locator('button.search-btn');
  }
  ```

## 5. Follow Playwright Community Standards
- **ALWAYS** follow official Playwright documentation and best practices
- **USE** recommended patterns from Playwright community
- **REFER** to https://playwright.dev for official guidance
- **AVOID** anti-patterns and deprecated methods
- Examples of community standards:
  - Use `test.describe()` for grouping tests
  - Use `test.beforeEach()` for setup
  - Use proper assertions with `expect()`
  - Use `page.waitForLoadState()` when needed
  - Use `test.step()` for better test reporting
  - Follow naming conventions (describe blocks, test names)

## 6. Use Fixtures to Speed Up Tests and for Clean Coding
- **ALWAYS** use custom fixtures for Page Object Models
- **CREATE** fixtures in `tests/fixtures.ts` or similar
- **EXTEND** Playwright's `test` object with custom fixtures
- **INJECT** page objects through fixtures instead of instantiating in tests
- **BENEFITS**: Faster test execution, cleaner code, better reusability, automatic cleanup
- Example:
  ```typescript
  // ✅ CORRECT - Using fixtures
  import { test as base } from '@playwright/test';
  import { HomePage } from '../pages/HomePage';
  
  type TestFixtures = {
    homePage: HomePage;
  };
  
  export const test = base.extend<TestFixtures>({
    homePage: async ({ page }, use) => {
      const homePage = new HomePage(page);
      await homePage.goto('/');
      await use(homePage);
    },
  });
  
  // In test file
  test('should verify elements', async ({ homePage }) => {
    await expect(homePage.myAccountLink).toBeVisible();
  });
  
  // ❌ WRONG - Instantiating in test
  test('should verify elements', async ({ page }) => {
    const homePage = new HomePage(page);
    await homePage.goto('/');
    await expect(homePage.myAccountLink).toBeVisible();
  });
  ```

## 7. Always Use Await, Never Silently Catch Errors
- **ALWAYS** use `await` for async operations
- **NEVER** use `.catch(() => {})` to silently swallow errors
- **ENSURE** operations complete before proceeding to next steps
- **BENEFITS**: Better error visibility, improved CI reliability, ensures operations complete
- Example:
  ```typescript
  // ✅ CORRECT - Using await
  async navigateToProducts(): Promise<void> {
    await this.productsLink.click();
    await this.handleCookieConsent();
    await this.page.waitForURL('**/products**');
  }
  
  // ❌ WRONG - Silently catching errors
  async navigateToProducts(): Promise<void> {
    await this.productsLink.click();
    this.handleCookieConsent().catch(() => {});
    await this.page.waitForURL('**/products**');
  }
  ```

## Additional Best Practices
- Use TypeScript for type safety
- Keep page objects focused and single-responsibility
- Use descriptive names for getters and methods
- Group related selectors together logically

